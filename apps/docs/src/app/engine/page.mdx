# Game Engine Overview

The NovAI game engine is the core system that manages game state, processes actions, and coordinates between the AI agent and the game world.

## Architecture

The game engine consists of several key components:

```
Game Engine
├── Game State Manager
├── Action Processor
├── Rules Engine
├── Campaign Manager
└── Event System
```

## Core Components

### 1. Game State Manager

Manages the current state of the game:

```typescript
interface GameState {
  characters: Character[];
  location: Location;
  inventory: Item[];
  quests: Quest[];
  events: GameEvent[];
  metadata: GameMetadata;
}
```

### 2. Action Processor

Processes player actions and AI responses:

```typescript
interface Action {
  type: 'move' | 'attack' | 'talk' | 'use' | 'custom';
  target?: string;
  parameters?: Record<string, any>;
  timestamp: Date;
}
```

### 3. Rules Engine

Applies game rules and mechanics:

```typescript
interface RulesEngine {
  validateAction(action: Action, state: GameState): boolean;
  applyAction(action: Action, state: GameState): GameState;
  calculateOutcome(action: Action, state: GameState): Outcome;
}
```

## Game State Management

### State Structure

```typescript
interface GameState {
  // Core game elements
  characters: {
    player: PlayerCharacter;
    npcs: NPC[];
  };
  
  // World state
  location: {
    name: string;
    description: string;
    exits: Exit[];
    items: Item[];
    npcs: NPC[];
  };
  
  // Player state
  inventory: Item[];
  health: number;
  experience: number;
  level: number;
  
  // Game progress
  quests: Quest[];
  completedEvents: GameEvent[];
  worldState: WorldState;
}
```

### State Updates

The game state is updated through a series of actions:

```typescript
// Example: Player moves to a new location
const action: Action = {
  type: 'move',
  target: 'tavern',
  parameters: { method: 'walk' }
};

const newState = rulesEngine.applyAction(action, currentState);
```

## Action System

### Action Types

1. **Movement Actions**
   - `move` - Move to a new location
   - `explore` - Search current location
   - `travel` - Long-distance travel

2. **Combat Actions**
   - `attack` - Attack a target
   - `defend` - Defend against attack
   - `cast` - Cast a spell
   - `use` - Use an item or ability

3. **Social Actions**
   - `talk` - Talk to an NPC
   - `persuade` - Attempt persuasion
   - `intimidate` - Attempt intimidation
   - `bargain` - Negotiate prices

4. **Interaction Actions**
   - `examine` - Examine an object
   - `take` - Pick up an item
   - `drop` - Drop an item
   - `use` - Use an item

### Action Processing

```typescript
async function processAction(action: Action, state: GameState): Promise<GameState> {
  // 1. Validate action
  if (!rulesEngine.validateAction(action, state)) {
    throw new Error('Invalid action');
  }
  
  // 2. Apply rules
  const newState = rulesEngine.applyAction(action, state);
  
  // 3. Generate AI response
  const aiResponse = await aiAgent.processAction(action, newState);
  
  // 4. Update state with AI response
  return updateStateWithAIResponse(newState, aiResponse);
}
```

## Rules Engine

### Rule Types

1. **Validation Rules**
   - Check if action is valid
   - Verify prerequisites
   - Ensure game balance

2. **Application Rules**
   - Apply action effects
   - Update game state
   - Trigger events

3. **Outcome Rules**
   - Calculate results
   - Determine consequences
   - Update statistics

### Example: Combat Rules

```typescript
const combatRules = {
  validateAttack: (action: Action, state: GameState) => {
    const attacker = state.characters.player;
    const target = findTarget(action.target, state);
    
    return attacker.health > 0 && 
           target && 
           target.health > 0 &&
           isInRange(attacker, target);
  },
  
  applyAttack: (action: Action, state: GameState) => {
    const damage = calculateDamage(action, state);
    const newState = { ...state };
    
    // Apply damage to target
    newState.characters.npcs = newState.characters.npcs.map(npc => 
      npc.id === action.target 
        ? { ...npc, health: Math.max(0, npc.health - damage) }
        : npc
    );
    
    return newState;
  }
};
```

## Campaign Management

### Campaign Structure

```typescript
interface Campaign {
  id: string;
  name: string;
  description: string;
  ruleset: string;
  dataSources: string[];
  aiAgent: AIAgentConfig;
  world: WorldConfig;
}
```

### Campaign Loading

```typescript
async function loadCampaign(campaignId: string): Promise<Campaign> {
  const campaignData = await loadCampaignData(campaignId);
  const dataSources = await loadDataSources(campaignData.dataSources);
  const aiAgent = await initializeAIAgent(campaignData.aiAgent);
  
  return {
    ...campaignData,
    dataSources,
    aiAgent
  };
}
```

## Event System

### Event Types

1. **World Events**
   - Weather changes
   - Time progression
   - NPC movements

2. **Player Events**
   - Level up
   - Quest completion
   - Item acquisition

3. **Story Events**
   - Plot progression
   - Character development
   - World changes

### Event Processing

```typescript
interface Event {
  type: string;
  timestamp: Date;
  data: any;
  priority: 'low' | 'medium' | 'high';
}

async function processEvents(state: GameState): Promise<GameState> {
  const pendingEvents = getPendingEvents(state);
  
  for (const event of pendingEvents) {
    state = await processEvent(event, state);
  }
  
  return state;
}
```

## Integration with AI Agent

### State Synchronization

The game engine maintains synchronization with the AI agent:

```typescript
// When AI generates a response
const aiResponse = await aiAgent.processAction(action, state);

// Update game state with AI response
const updatedState = {
  ...state,
  events: [...state.events, {
    type: 'ai_response',
    timestamp: new Date(),
    data: aiResponse
  }]
};
```

### Context Provision

The engine provides context to the AI agent:

```typescript
const context = {
  currentState: state,
  recentActions: getRecentActions(state),
  availableActions: getAvailableActions(state),
  worldContext: getWorldContext(state)
};

const aiResponse = await aiAgent.processWithContext(action, context);
```

## Performance Optimization

### State Caching

```typescript
const stateCache = new Map<string, GameState>();

function cacheState(key: string, state: GameState) {
  stateCache.set(key, JSON.parse(JSON.stringify(state)));
}

function getCachedState(key: string): GameState | null {
  return stateCache.get(key) || null;
}
```

### Action Batching

```typescript
const actionQueue: Action[] = [];

function queueAction(action: Action) {
  actionQueue.push(action);
}

async function processActionQueue() {
  while (actionQueue.length > 0) {
    const batch = actionQueue.splice(0, 10);
    await processActionBatch(batch);
  }
}
```

## Best Practices

### 1. State Immutability

Always create new state objects instead of mutating existing ones:

```typescript
// Good
const newState = { ...state, characters: { ...state.characters } };

// Bad
state.characters.player.health = 50;
```

### 2. Action Validation

Always validate actions before applying them:

```typescript
if (!rulesEngine.validateAction(action, state)) {
  throw new Error(`Invalid action: ${action.type}`);
}
```

### 3. Error Handling

Handle errors gracefully and maintain game state:

```typescript
try {
  const newState = await processAction(action, state);
  return newState;
} catch (error) {
  console.error('Action processing failed:', error);
  return state; // Return unchanged state
}
```

### 4. Performance Monitoring

Monitor engine performance:

```typescript
const metrics = {
  actionProcessingTime: number;
  stateUpdateTime: number;
  memoryUsage: number;
  errorRate: number;
};
```

## Next Steps

- **[Game State](/engine/game-state)** - Deep dive into state management
- **[Actions & Commands](/engine/actions)** - Learn about action processing
- **[Campaigns](/engine/campaigns)** - Understand campaign management
- **[Rulesets](/engine/rulesets)** - Explore rule system configuration 